1) Реализовать добавление внутреннего пользователя (ВнуП). Может быть даже напрямую обращаясь к базе данных из root-a. Добавление ВнуП --- это добавление username-password. Скорее всего я это сделаю так --- придумываю логин и пароль (хеширую пароль той же функцией, которой хешируется на сервере, получаю хеш, и этот хеш ввожу в ячейку.) Пока дынные по внутренним пользователям будем хранить просто в таблице excel. Далее по закрытому каналу (на бумажке) передаю ВнуП.

2) При отправке от десктопного клиента (ДК) серверу (Серв) первого сообщения, нужно чтобы в сообщении был логин и пароль (для аутентификации), а так же количеством нужных идентификаторов. Понимание к какому сервису относится данная прошивка и какой тип устройства я могу прописать в url т.е. имеется ввиду что нужно такой api придумать, чтобы понимание, того к камому сервису относится прошиваемое устройство и какой тип устройства, должен быть прописан в url/
У нас есть понятие типа устройства (датчик, хаб, головное устройство). Скорее всего для всех этих разных устройств придется создавать отделную базу.
Далее на основании того какие параметры я получил от клиента и согласно url я понимаю что мне нужно. А нужно мне зарезервировать  id-шники. Для резервации мне нужно знать кто зарезервировал, в рамках какой сессии, и собственно индексы которые зарезервированы.

Как я это делаю!? Сначала регистрирую новую сессию в таблице sessions для этого нам нужно user_id и данный параметер у нас есть из логина пароля в url-запросе. Далее у меня есть id сессии, который я получаю из возращенных данных. Далее я должен зарезервировать id-шники у меня есть тип дивайса, и для и я делаю по одному запросу для каждого id-шника, получаю айдишник и делаю резервацию уже в таблице axleloadsensors. И так несколько раз пока не зарезервирую все id. Потом запрашиваю из таблицы devices все записи с условием session_id = данная сессия AND device_jastreserved = 1 AND delete_ != 0. И получаем список айдишников которые нужно отправить. Зашиваю id сессии в токен. И все это передаю JSON клиенту.

Если в течении какого-то времени (надо с Темой пообщаться) второй запрос не поступит, то нужно будет сессию закрыть.(Это вопрос обсуждаемый, надо понять --- есть ли в открытой сессии проблемы). Скорее всего сессии закрывать не надо на основании долгого срока открытия. Скорее всего придется закрывать сессию после истечения срока действия токена, хотя это не точно. Так же нужно как-то пометить зарезервированные id-ки о том, что сессия просрочена и id-ки уже будут не нужны. Помечаю такие id-ки deleted_ 1. Id-ки помечаются как удаленные по причине просрочки скриптом, который запускается раз в сутки и "удаляет" все сессии и дивайсы срок регистрации которых превышает срок жизни токена.

Сервер получает от клиента запрос в котором есть токен и параметры датчика. 
Сначала я выясняю проходит ли токен аутентификацию-идентификация. Если не проходит уведомляю, что "У Вас неправильный токен. Ожидаю правильный токен".
Затем извлекаю из токена идентификатор сессии. Надо понимать, что у одного и того же пользователя на втором этапе взаимодействия разница между разными сессиями будет в количестве зарезервированных идентификаторов и значениями этих идентификаторов. Поэтому мы должны проверить значения идентификаторов привязанных к данной сессии. Если идентификаторы зарезервированные и идентификаторы полученные в параметрах не совпадают, то отправляю сообщение "Под данной сессией зарезервированы следующие идентификаторы: 1, 2, 3, 4. А в запросе указаны идентификаторы 23, 24, 25". Если же они совпадают, то я делаю update записей в таблице axleloadsensors." и отправляю сообщение о том что все хорошо. 

Далее сервер ждет ответ от клиента о том, что все хорошо. В данном сообщении должен быть токен и параметер ready_products в котором должен быть массив id-ков устройств, которые успешно прошились. 
Я проверяю эти id-ки на предмет находятся ли они в состоянии jastreserved 1 и проверяю соответсвуют ли они данной сессии. И если они не находятся в таком состоянии, то я фиксирую это и потом отправляю этот список вместе с ответом.
Я помечаю в таблице devices поле device_jastreserved со значением 0. 
Далее по id-сессии я определяю в таблице devices остались ли записи с полями device_jastreserved равными 1. Если остались то ничего не далаю, если же не остались, то помечаю в таблице sessions запись с данной сессией как deleted_ . И отправляю сообщение что устройства под такими то id зарегестированы, а если есть id-которые были зарегестрированы ранее, то сообщаю, об этом.
